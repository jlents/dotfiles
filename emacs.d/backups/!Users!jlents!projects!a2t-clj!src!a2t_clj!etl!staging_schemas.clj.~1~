;;;; Put validation/transform schemas for the staging data here.  These will be
;;;; used in the Data Hygiene phase of the ETL process.  Define :fns as [] to
;;;; server as a placeholder.  The value will be replaced by data in the DB.

(ns a2t-clj.etl.staging-schemas
  (:require [a2t-clj.etl.data :as etl-data]
            [a2t-clj.etl.staging-transforms :as trans]
            [a2t-clj.etl.staging-validation :as validate]
            [a2t-clj.utility :as util]
            [schema.core :as s]))

(def mforce
  {:aagr {:check (s/pred #(validate/numeric? % 5))
          :fns []}
   :actco {:check (s/pred #(clojure.set/subset? #{%} etl-data/action-code-list))
           :fns []}
   :aenl  {:check (s/pred #(validate/numeric? % 5))
           :fns []}
   :amsco {:check (s/both (s/pred #(string? %))
                          (s/pred #(= (count %) 9)))
           :fns []}
   :aoff  {:check (s/pred #(validate/numeric? % 5))
           :fns []}
   :asgmt {:check (s/pred #(clojure.set/subset? #{%} etl-data/command-code-list))
           :fns []}
   :awof {:check (s/pred #(validate/numeric? % 5))
          :fns []}
   :branch {:check (s/either (s/pred #(empty? %))
                             (s/pred #(clojure.set/subset? #{%} etl-data/branch-code-list)))
            :fns []}
   :cars {:check (s/pred #(< (count %) 3))
          :fns []}
   :ccnum {:check (s/pred #(validate/mforce-ccnum? %)) ; TODO: Maybe get more in depth on this one?
           :fns []}
   :compo {:check (s/both (s/pred #(< 0 %))
                          (s/pred #(> 10 %)))
           :fns []}
   :darpl {:check (s/pred (and not-empty #(< (count %) 6)))
           :fns []}
   :docno {:check (s/either
                   (s/pred #(empty? %))
                   (s/pred #(= 10 (count %))))
           :fns []}
   :dp-99 {:check (s/pred #(clojure.set/subset? #{%} etl-data/dp99-code-list))
           :fns []}
   :dscmp {:check (s/enum "DC" "DO") ; TODO: I think we should convert this to bool.
           :fns []}
   :edate {:check (s/either (s/pred #(empty? %))
                            (s/pred #(= org.joda.time.DateTime (type %))))
           :fns []}
   :elseq {:check (s/either (s/pred #(empty? %))
                            (s/pred #(clojure.set/subset? #{%} etl-data/elseq-code-list)))
           :fns []}
   :fad {:check (s/pred #(and (< 0 %) (> 6 %)))
         :fns []}
   :locco {:check (s/pred #(> 4 (count %))) ; TODO: Get the list of LOCCO Codes.
           :fns []}
   :mdep {:check (s/pred #(= 4 (count %))) ; TODO: We need to decipher this guy.
          :fns []}
   :multi-ams {:check s/Bool
               :fns []}
   :phase {:check (s/pred #(clojure.set/subset? #{%} etl-data/phase-code-list))
           :fns[]}
   :ragr {:check (s/pred #(validate/numeric? % 5))
          :fns []}
   :remarks {:check s/Str
             :fns []}
   :renl {:check (s/pred #(validate/numeric? % 5))
          :fns []}
   :roc {:check  (s/pred #(>= 3 (count %))) ; TODO: Another loaded field.
         :fns []}
   :roff {:check (s/pred #(validate/numeric? % 5))
          :fns []}
   :rwof {:check (s/pred #(validate/numeric? % 5))
          :fns []}
   :src {:check (s/either (s/pred #(empty? %))
                          (s/pred #(validate/mforce-src? %)))
         :fns []}
   :staco {:check (s/pred #(= 5 (count %))) ; TODO: Get the station codes maybe?
           :fns []}
   :stnnm {:check (s/pred #(> 10 (count %))) ; TODO: Get the station codes maybe?
           :fns []}
   :tdate {:check (s/either (s/pred #(empty? %))
                            (s/pred #(= org.joda.time.DateTime (type %))))
           :fns []}
   :tpsn {:check (s/pred #(clojure.set/subset? #{%} etl-data/mtoe-tpsn-code-list))
          :fns []}
   :typco {:check (s/pred #(and (> % 0) (< % 4)))
           :fns []}
   :udp-99 {:check (s/either (s/pred #(empty? %))
                             (s/pred #(clojure.set/subset? #{%} etl-data/dp99-code-list)))
            :fns []}
   :uic {:check (s/pred #(validate/uic? %))
         :fns []}
   :ulc {:check s/Str
         :fns []}
   :unmbr {:check (s/pred #(>= 4 (count %)))
           :fns[]}
   :untds {:check s/Str
           :fns []}})

(def usrcomments
  {:uic               {:check (s/pred #(validate/uic? %))}
   :aname             {:check s/Str}
   :concern-rank      {:check s/Int}
   :comments-label    {:check (apply s/enum etl-data/comment-labels)}
   :concern-title     {:check s/Str}
   :concern-key       {:check s/Str}
   :commander-comment {:check s/Str}
   :ricda             {:check org.joda.time.DateTime}})

(def usroverall
  {:acc-definition {:check s/Str
<<<<<<< HEAD
                    :fns []}
   :abbreviated-name {:check s/Str
                      :fns []}
   :arpl {:check (s/both (s/pred #(not-empty %))
=======
          :fns []}
   :aname {:check s/Str
          :fns []}
   :army-resourcing-pri-list-cd {:check (s/both (s/pred #(not-empty %))
>>>>>>> implementing usroverall.
                         (s/pred #(< (count %) 6)))
          :fns []}
   :bide-home-location {:check s/Str
                        :fns []}
   :bide-present-location {:check s/Str
<<<<<<< HEAD
                           :fns []}
   :cdr-commm-phone {:check (s/pred #(validate/phone-number? %))
                     :fns []}
=======
          :fns []}
   :cdr-comm-phone {:check (s/pred #(validate/phone-number? %))
          :fns []}
>>>>>>> implementing usroverall.
   :cdr-dsn-phone {:check (s/pred #(validate/phone-number? %))
                   :fns []}
   :cdr-name {:check s/Str
              :fns []}
   :cdr-niprnet {:check (s/pred #(validate/email? %))
                    :fns []}
   :cdr-siprnet {:check (s/pred #(validate/email? %))
                    :fns []}
   :cocom-svc-comp-svc-agcy {:check s/Str
           :fns []}
   :compo {:check (s/both (s/pred #(< 0 %))
                          (s/pred #(> 10 %)))
           :fns []}
   :deployed-indicator-code {:check s/Str
                             :fns []}
<<<<<<< HEAD
   :equipment-on-hand-readiness {:check (s/pred #(clojure.set/subset? #{%} etl-data/equipment-on-hand-readiness-list))
                                 :fns []}
   :equipment-readiness {:check (s/pred #(clojure.set/subset? #{%} etl-data/equipment-readiness-list))
=======
   :eoh {:check (s/pred #(clojure.set/subset? #{%} etl-data/equipment-on-hand-readiness-list))
                       :fns []}
   :er {:check (s/pred #(clojure.set/subset? #{%} etl-data/equipment-readiness-list))
>>>>>>> implementing usroverall.
                         :fns []}
   :force-package {:check s/Str
                   :fns []}
   :force-pool {:check s/Str
                :fns []}
   :force-type {:check s/Str
                :fns []}
   :home-location {:check s/Str
                   :fns []}
   :loc {:check s/Str
         :fns []}
   :mcu {:check s/Str
         :fns []}
   :named-operation {:check s/Str
                     :fns []}
   :per {:check (s/pred #(clojure.set/subset? #{%} etl-data/personnel-readiness-list))
                         :fns []}
   :present-location {:check s/Str
                      :fns []}
   :ready {:check (s/pred #(clojure.set/subset? #{%} etl-data/unit-readiness-list))
                    :fns []}
   :reason {:check s/Str
                           :fns []}
   :reset-date {:check (s/either (s/pred #(empty? %))
                                 (s/pred #(= org.joda.time.DateTime (type %))))
                :fns []}
   :ricda {:check (s/either (s/pred #(empty? %))
                                  (s/pred #(= org.joda.time.DateTime (type %))))
                 :fns []}
<<<<<<< HEAD
   :training-readiness {:check (s/pred #(clojure.set/subset? #{%} etl-data/training-readiness-list))
                        :fns []}
=======
   :tng {:check (s/pred #(clojure.set/subset? #{%} etl-data/training-readiness-list))
                    :fns []}
>>>>>>> implementing usroverall.
   :tpsn {:check (s/pred #(clojure.set/subset? #{%} etl-data/mtoe-tpsn-code-list))
          :fns []}
   :uic {:check (s/pred #(validate/uic? %))
         :fns []}})

(def probe
  {:ape {:check (s/both (s/pred #(string? %))
                        (s/pred #(= (count %) 6)))
         :fns []}
   :appn {:check s/Str
          :fns []}
   :bo {:check (s/pred #(clojure.set/subset? #{%} etl-data/bo-list))
        :fns []}
   :ctc {:check (s/pred #(clojure.set/subset? #{%} etl-data/ctc-list))
         :fns []}
   :cwoc {:check (s/pred #(clojure.set/subset? #{%} etl-data/cwoc-list))
          :fns []}
   :mdep {:check s/Str
          :fns []}
   :osdpe {:check s/Str
           :fns []}
   :rc {:check s/Str
        :fns []}
   :ric {:check (s/pred #(validate/numeric? % 4))
         :fns []}
   :roc {:check s/Str
         :fns []}
   :sfy {:check (s/pred #(validate/numeric? % 2))
         :fns []}
   :spc {:check (s/pred #(validate/numeric? % 3))
         :fns []}
   :uic {:check (s/both (s/pred #(empty? %))
                        (s/pred #(validate/uic? %)))
         :fns []}
   :year-1 {:check s/Str
            :fns []}
   :year-2 {:check s/Str
            :fns []}
   :year-3 {:check s/Str
            :fns []}
   :year-4 {:check s/Str
            :fns []}
   :year-5 {:check s/Str
            :fns []}
   :year-6 {:check s/Str
            :fns []}
   :year-7 {:check s/Str
            :fns []}
   :year-8 {:check s/Str
            :fns []}
   :year-9 {:check s/Str
            :fns []}})

;; Schema for unit/integration tests. Do not remove yet.
(def testforce
  {:uic {:check (s/pred (and s/Str #(= (count %) 6)))
         :fns []}
   :free-text {:check s/Str
               :fns []}
   :date-something-happened {:check org.joda.time.DateTime
                             :fns []}
   :enum-value {:check (s/enum "DIV" "BDE" "BN" "CO")
                :fns []}
   :pos-number {:check (s/pred (and s/Int pos?))
                :fns []}})
